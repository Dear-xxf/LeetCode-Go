package Trick

import "sort"

/*
   题目描述：
	Middle 下一个排列
	整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
	例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
	整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
	例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
	类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
	而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
	给你一个整数数组 nums ，找出 nums 的下一个排列。
	必须 原地 修改，只允许使用额外常数空间。
*/

/*
   解题思路：
	这道题写的毫无头绪；
	重点在于发现排列从顺序到乱序的过程中打乱的方式，发现每次“下一个排列”都是在当前排列的基础上，寻找最小的变化，使得排列变大；
		1.从后往前找到第一个升序的位置：也就是找到一个下标 i，使得 nums[i] < nums[i+1]。这一步是找到“打破最大排列的转折点”，表示我们还能变大。
		2.再从后往前找第一个大于 nums[i] 的数 nums[j]：这样可以确保交换后整体变大，但又是“最小的变大”。
		3.交换 nums[i] 和 nums[j]：使排列稍微变大。
		4.将 i+1 之后的子数组进行升序排列（实际上是反转，因为原本是降序）：让整体变成下一个最小的排列。
	如果找不到 i（即整个数组是降序的），说明当前排列已经是最大了，直接 反转整个数组 即可得到最小排列（即从头再来）。
*/

func nextPermutation(nums []int) {
	last := len(nums) - 2
	for last >= 0 {
		if nums[last] < nums[last+1] {
			break
		}
		last--
	}
	if last == -1 {
		sort.Ints(nums)
		return
	}
	pos := last
	last = len(nums) - 1
	for last >= 0 {
		if nums[last] > nums[pos] {
			break
		}
		last--
	}
	nums[last], nums[pos] = nums[pos], nums[last]
	for l, r := pos+1, len(nums)-1; l < r; l, r = l+1, r-1 {
		nums[l], nums[r] = nums[r], nums[l]
	}
}
